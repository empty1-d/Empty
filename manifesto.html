<!DOCTYPE html>They called themselves —
              <span class="section-word em" data-type-target>The Miners.</span>
            </p>

            <p data-type-target>It would only be a matter of time before others would follow.</p>

            <p data-type-target>They who bargain with governance in pursuit of asymmetry.</p>

            <p data-type-target>
              They declared themselves
              <span class="section-word" data-type-target>the Custodians of Order—</span>
              the quiet stewards of value, <br /> 
              heralding vast horizons <br />
              where tokenized wealth would rise without end.
            </p>

            <p data-type-target>But, too often it is the case that, where wallets fill, greed lurks not too far behind.</p>

            <p data-type-target>It is from this greed and hunger that a new class of belief was validated.</p>

            <p data-type-target>
              <span class="section-word em" data-type-target>The Traders' belief.</span>
            </p>

            <img
              src="Failed-double-bottom-pattern-1024x502.jpg"
              alt="Traders' expectations versus reality"
              class="manifesto-image"
            />

            <p data-type-target>
              They worshiped the candle, feared the wick. <br />
              Charts and leverage became their scripture, <br />
              patterns the crucible of their prophecies.
            </p>

            <p data-type-target>Then, within their ranks, a new sect rose.</p>

            <p data-type-target>
              <span class="section-word em" data-type-target>The DEGEN</span>
            </p>

            <img
              src="avatars-000302542401-bjpp2n-t500x500.jpg"
              alt="Trader staring into the void of the chart"
              class="manifesto-image"
            />

            <p data-type-target>
              They feared nothing, <br /> 
              restrained nothing, <br />
              propelled by the propensity of a lucrative enterprise.</p>
            
            <p>  Volatility was their codec, chaos their altar. <br />
              Memes became their icons, tokens their temples. </p>
            <p>  Where markets burned, they scorned, for fire was proof of faith.
            </p>

            <p data-type-target>
              Inevitably
              their gospel would spread:<br />
              “HODL!”<br />
              "Buy the dip!"<br />
              “Diamond hands!"<br />
              "To the moon!"
            </p>

            <p data-type-target>Words initially invoked for perseverance, conviction and courage.</p>

            <p data-type-target>
              But as cycles turned, <br />
              the candles dimmed, <br />
              and the illusion of scarcity faded. </p>
            <p> These sacred phrases became cheap slogans of survival against the unflinching circumstance of declining portfolios.
            </p>

            <p data-type-target>Thus a quiet truth now emerges from the ashes of euphoria:</p>

            <p data-type-target>
              For all the noise,<br />
              for all the faith, and<br />
              for all the unshaken grip…
            </p>

            <p data-type-target>the wallets remain still. Numbers that shimmer without weight.</p>

            <p class="closing-word" data-type-target>
              And the diamond hands —<br />
              cold, perfect, unyielding —<br />
              remain…
            </p>

            <p class="closing-word token-empty" data-type-target>$empty.</p>

            <img
              src="file_000000005fa861f58aa14de0a05be33b.jpg"
              alt="Diamond hands held out, empty"
              class="manifesto-image"
            />
          </div>
        </div>
      </div>
    </div>

    <!-- DISCLAIMER -->
   <aside class="disclaimer">
  <div class="disclaimer-inner">
    <div class="disclaimer-title">EMPTY / DISCLAIMER</div>

    <p>
      Fair warning — you may feel a strong urge to HODL, buy the dip,  
      or even diamond hand <span class="token">$emptycoin</span>.
    </p>

    <p>
      Our take: meme tokens are inherently speculative in nature,  
      so it's always wise to DYOR.
    </p>

    <p>
      On the other hand… people do strange things when they believe in something.
    </p>

    <div class="disclaimer-actions">
      <a href="resist.html" class="disclaimer-btn ghost">
        Resist the call of the emptiness
      </a>

      <a href="embrace.html" class="disclaimer-btn">
        Embrace the futility
      </a>
    </div>

  </div>
   </aside>
    
  </div>

  <script>
  // gentle auto-scroll of the parchment (robust start)
  const scrollInner = document.getElementById("scroll-inner");
  let autoScrollActive = true;
  const speed = 0.3; // pixels per frame

  function autoScrollStep() {
    if (!autoScrollActive) return;
    const maxScroll = scrollInner.scrollHeight - scrollInner.clientHeight;
    if (scrollInner.scrollTop >= maxScroll) {
      autoScrollActive = false;
      return;
    }
    scrollInner.scrollTop += speed;
    requestAnimationFrame(autoScrollStep);
  }

  function startAutoScrollWithDelay(delay = 2500) {
    // only start if it's possible to scroll
    if (scrollInner.scrollHeight <= scrollInner.clientHeight) return;
    setTimeout(() => {
      // guard: don't start if user already interacted and canceled auto-scroll
      if (!autoScrollActive) return;
      requestAnimationFrame(autoScrollStep);
    }, delay);
  }

  // Robustly start auto-scroll when page finishes loading
  if (document.readyState === "complete") {
    startAutoScrollWithDelay(2500);
  } else {
    window.addEventListener("load", () => startAutoScrollWithDelay(2500));
  }

  // If the user starts interacting with the scroll container, stop auto-scroll
  // but DO NOT reveal the typing on touch/drag — that allows native scrolling.
  ["wheel", "touchstart", "scroll"].forEach((evt) => {
    scrollInner.addEventListener(
      evt,
      () => {
        autoScrollActive = false;
        // Only reveal text on scroll if typing already finished — keep touch from revealing.
        // If you want touch to reveal, call revealAllRemaining() here intentionally.
      },
      { passive: true }
    );
  });

  // fade-in images when they enter the viewport of the scroll container
  const images = document.querySelectorAll(".manifesto-image");

  if ("IntersectionObserver" in window) {
    const io = new IntersectionObserver(
      (entries, observer) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("visible");
            observer.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.2, root: scrollInner }
    );
    images.forEach((img) => io.observe(img));
  } else {
    images.forEach((img) => img.classList.add("visible"));
  }

  /* ---------------------------
     PER-CHARACTER TYPEWRITER
     --------------------------- */

  const TYPE_SELECTOR = "[data-type-target]";
  const baseCharDelay = 60; // ms per character
  const variance = 28;
  const elementStagger = 350;
  const caretForElements = false;

  let typingActive = true;
  let typingStarted = false;
  let typingQueue = [];

  function normalizeText(t) {
    return t.replace(/\r/g, "");
  }

  function buildTypingQueue() {
    typingQueue = [];
    const elements = Array.from(document.querySelectorAll(TYPE_SELECTOR));
    const filtered = elements.filter(el => {
      const txt = el.textContent.trim();
      return txt.length > 0;
    });
    filtered.forEach((el) => {
      const original = normalizeText(el.innerText || el.textContent || "");
      typingQueue.push({ el, original });
    });
  }

  function prepareElement(el) {
    el.innerHTML = "";
    const frag = document.createDocumentFragment();
    const charWrap = document.createElement("span");
    charWrap.className = "typing-wrap";
    frag.appendChild(charWrap);
    el.appendChild(frag);
    return charWrap;
  }

  function makeCharNode(ch) {
    const span = document.createElement("span");
    span.className = "typing-char";
    if (ch === " ") {
      span.innerHTML = "&nbsp;";
    } else if (ch === "\n") {
      span.innerHTML = "<br>";
    } else {
      span.textContent = ch;
    }
    return span;
  }

  function typeElement(el, text, startDelay = 0) {
    return new Promise((resolve) => {
      const wrap = prepareElement(el);
      let caret;
      if (caretForElements) {
        caret = document.createElement("span");
        caret.className = "typing-caret";
        el.appendChild(caret);
      }

      let index = 0;

      function nextChar() {
        if (!typingActive) {
          revealRemainingForElement(wrap, text.slice(index));
          if (caret) caret.remove();
          resolve();
          return;
        }

        if (index >= text.length) {
          if (caret) caret.remove();
          resolve();
          return;
        }

        const ch = text[index++];
        const node = makeCharNode(ch);
        wrap.appendChild(node);
        requestAnimationFrame(() => node.classList.add("visible"));

        const rnd = Math.floor((Math.random() - 0.5) * variance);
        const delay = Math.max(6, baseCharDelay + rnd);
        setTimeout(nextChar, delay);
      }

      setTimeout(() => nextChar(), startDelay);
    });
  }

  function revealRemainingForElement(wrap, remainingText) {
    for (let i = 0; i < remainingText.length; i++) {
      const ch = remainingText[i];
      const node = makeCharNode(ch);
      wrap.appendChild(node);
      node.classList.add("visible");
    }
  }

  function revealAllRemaining() {
    typingActive = false;
    document.querySelectorAll(TYPE_SELECTOR).forEach((el) => {
      const wrap = el.querySelector(".typing-wrap");
      if (!wrap) return;
      const full = el.__originalText || el.getAttribute("data-original-text") || "";
      if (!full) return;
      const currentChars = wrap.querySelectorAll(".typing-char").length;
      const remaining = full.slice(currentChars);
      if (remaining && remaining.length > 0) {
        revealRemainingForElement(wrap, remaining);
      }
    });

    typingQueue.forEach(({ el, original }) => {
      if (!el.querySelector(".typing-wrap")) {
        el.innerText = original;
      }
    });
  }

  async function runTypingSequence() {
    typingStarted = true;
    buildTypingQueue();
    typingQueue.forEach(item => item.el.__originalText = item.original);

    for (let i = 0; i < typingQueue.length; i++) {
      const { el, original } = typingQueue[i];
      if (!typingActive) break;
      await typeElement(el, original, 0);
      await new Promise(res => setTimeout(res, elementStagger));
    }

    typingActive = false;
  }

  // Robust DOM ready: run even if script executed after DOMContentLoaded
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => runTypingSequence().catch(()=>{}), 600);
    });
  } else {
    setTimeout(() => runTypingSequence().catch(()=>{}), 600);
  }

  // Only reveal on explicit click/tap. Do NOT reveal on touchstart so users can scroll.
  document.addEventListener("click", () => {
    if (typingActive && typingStarted) revealAllRemaining();
  }, { passive: true });

  // If you prefer a two-finger tap or a long-press to reveal, I can add that instead.

  /* END typewriter */
    </script>
                  
</body>
  </html>
        
